Unity 2019.4.3

Реализация ЗАДАЧА 4. Разбиение отрезков

I. АЛГОРИТМ РЕАЛИЗАЦИИ	
   1. Первый этап - нахожнение пересечения между двумя отрезками (class SingleCrossSegments.cs):
      - По заданным точкам, на основе свойства векторного произведения определяем пересекаются отрезки или нет( методы: CheckCrossing() и VectorMultiplication() )
      - Если пересекаются, используем метод построения прямой LineEquation() 
      - в методе CrossingPoint(), решая систему линейных уравнений методом Крамера, находим ТОЧКУ ПЕРЕСЕЧЕНИЯ.

   2. на основании 1. релизуем алгоритм множественных пересечений( class MultiCrossSegvemns.cs)
      - на входе - массив ОТРЕЗКОВ.
      
       - формируем промежуточный массив "массивов точек"("зубчатый массив" по сигнатуре Array[][] НЕ ДВУМЕРНЫЙ!!!:) )
                                                         ( List<List<Point>> _pointsOfSements; )
        [0]{p1, p2, p3, .....pn}
        [1]{p1, p2, p3, .....pn}
        [2]{p1, p2, p3, .....pn}
        .......................
        [n]{p1, p2, p3, .....pn}
      
       - при инициализации массива, сразу вносим в каждый эллемент  начальные и конечный точки по каждому исходному отрезку.
        Получаем :
        [0]{p1, p2}
        [1]{p1, p2}
        [2]{p1, p2}
        ...........
        [n]{p1, p2}
       
       - ищем точки пересечений отрезков и вносим их в созданный массив(_pointsOfSements) по принципу принадлежности отрезка.
         Получаем типа:
        [0]{p1, p2}                                              - первый отрезок
        [1]{p1, p2, p3}                                          - второй отрезок
        [2]{p1, p2, p3, p4, p5, p6, p7}                          - третий отрезок
        [3]{p1, p2, p3, p4, p5}                                   ...............
        [4]{p1, p2, p3, p4}                                       ...............  
        [5]{p1, p2, p3, p4}                                       ...............
        ............                        и т.д. по количеству входных отрезков
        
        - упорядочиваем полученный массив, так чтоб в каждом отрезке, точки шли последовательно (для их дальнейшегопреобразовния в отрезки ).
 
        - из полученного массива формируем ВЫХОДНОЙ массив отрезков ( List<Segment> _outArraySegments ) путем перебора отрезков, 
          а в каждом отрезке перебирая пары соседних точек.
          По нашему примеру, так:
                     отрезок0 - [0](p1,p2), 
                     отрезок1 - [1](p1,p2), 
                     отрезок2 - [1](p2,p3),
                     отрезок3 - [2](p1,p2),
                     отрезок4 - [2](p2,p3),
                     отрезок5 - [2](p3,p4),
                     .....................
                     отрезокN - [5](p3,p4)

II. Структура реализации ( В исходном задании - пункт б) ): 
     - сущность ТОЧКА   Реализовано в класе Point
     - сущность ОТРЕЗОК в классе Segment c инкапсуляцией в нем друх Poin
     - метода пересечечия, описанный в задании, реализован в классе MultiCrossSegments.cs как :
                           public static List<Segment> CrossSegments(List<Segment> _inArraySegments)
      
III. Описание вспомогательных модулей, созданных для наглядности реализации.
     - CreateArray.cs  - формирует входной массив по геометрической интерпретации
     - DemoCross.cs    - по событию от кнопки "Рассчитать", обрабатывает ВХОДНОЙ МАССИВ, исользуя созданный метод CrossSegments. 
                         Объявляет и вызывает событие о сформированном "ВЫХОДНОМ МАССИВЕ" и, что "МОЖНО ЗАКРЫВАТЬ ПРИЛОЖЕНИЕ"
     - DrawSegments.cs - подписан на событие "Выходной массив сформирован" и отрисовывает отрезки из ВЫХОДНОГО МАССИВА
     - UIController    - подписан на событие "МОЖНО ЗАКРЫВАТЬ ПРИЛОЖЕНИЕ". 
                         Деактивирует кнопку расчета(временное решение т.к. в PlayMode  Application.Quit() не работает;  ).

*** В дополнени при необходимости можно пересчитать длины полученных отрезков. 
          
        
        